<html>
   <head>
      <meta http-equiv="Content-type" content="text/html; charset=utf-8">
      <title>Lab</title>
      <link rel="StyleSheet" type="text/css" href="../../style.css" />
   </head>
   <body>

<h2>Lab 1</h2>

<a href="lab1-intro.pdf">Wprowadzenie</a>

<p>
Zadanie polega na stworzeniu analizatora leksykalnego (skanera) dla prostego języka umożliwiającego obliczenia na macierzach.

Analizator leksykalny powinien rozpoznawać następujące leksemy:
<UL>
<LI> operatory binare: <texttt>+, -, *, /</texttt>
<LI> macierzowe operatory binarne (dla operacji element po elemencie): .+, .-, .*, ./
<LI> operatory przypisania: =, +=, -=, *=, /=
<LI> operatory relacyjne: <, >, <=, >=, !=, ==
<LI> nawiasy: (,), [,], {,}
<LI> operator zakresu: :
<LI> transpozycja macierzy: '
<LI> przecinek i średnik: ,  ;
<LI> słowa kluczowe: <code>if</code>, <code>else</code>, <code>for</code>, <code>while</code> 
<LI> słowa kluczowe: <code>break</code>, <code>continue</code> oraz <code>return</code>
<LI> słowa kluczowe: <code>eye</code>, <code>zeros</code> oraz <code>ones</code>
<LI> słowa kluczowe: <code>print</code>
<LI> identyfikatory (pierwszy znak identyfikatora to litera lub znak _, w kolejnych znakach mogą dodatkowo wystąpić cyfry)
<LI> liczby całkowite
<LI> liczby zmiennoprzecinkowe
<LI> stringi
</UL>

Dla rozpoznanych leksemów stworzony skaner powinien zwracać:

<UL>
<LI>odpowiadający token
<LI>rozpoznany leksem
<LI>numer linii
</UL>



Następujące znaki powinny być pomijane:
<UL>
<LI> białe znaki: spacje, tabulatory, znaki nowej linii
<LI> komentarze: komentarze rozpoczynające się znakiem # do znaku końca linii
</UL>

<p>
Przykład.<br>
Dla następującego <a href="example.txt">kodu</a>:

<pre class="code">
A = zeros(5); # create 5x5 matrix filled with zeros
B = ones(7);  # create 7x7 matrix filled with ones
I = eye(10);  # create 10x10 matrix filled with ones on diagonal and zeros elsewhere
D1 = A.+B' ;  # add element-wise A with transpose of B
D2 -= A.-B' ; # substract element-wise A with transpose of B
D3 *= A.*B' ; # multiply element-wise A with transpose of B
D4 /= A./B' ; # divide element-wise A with transpose of B
</pre>

analizator leksykalny powinien zwracać następującą sekwencję i wypisywać ją na standardowym wyjściu:

<pre class="code">
(1): ID(A)
(1): =(=)
(1): ZEROS(zeros)
(1): ((()
(1): INTNUM(5)
(1): )())
(1): ;(;)
(2): ID(B)
(2): =(=)
(2): ONES(ones)
(2): ((()
(2): INTNUM(7)
(2): )())
(2): ;(;)
(3): ID(I)
(3): =(=)
(3): EYE(eye)
(3): ((()
(3): INTNUM(10)
(3): )())
(3): ;(;)
(4): ID(D1)
(4): =(=)
(4): ID(A)
(4): DOTADD(.+)
(4): ID(B)
(4): '(')
(4): ;(;)
(5): ID(D2)
(5): SUBASSIGN(-=)
(5): ID(A)
(5): DOTSUB(.-)
(5): ID(B)
(5): '(')
(5): ;(;)
(6): ID(D3)
(6): MULASSIGN(*=)
(6): ID(A)
(6): DOTMUL(.*)
(6): ID(B)
(6): '(')
(6): ;(;)
(7): ID(D4)
(7): DIVASSIGN(/=)
(7): ID(A)
(7): DOTDIV(./)
(7): ID(B)
(7): '(')
(7): ;(;)
</pre>


</p>


<UL>
<LI>Do rozwiązania zadania należy użyć generatora skanerów, np. generatora <code>PLY</code>.
<LI>Skaner powinien rozpoznawać niepoprawne leksykalnie wejście.
	W takim przypadku powinien zostać wypisany numer niepoprawnej linii wraz z szczegółową informacją o błędzie.
<LI>Do stworzenia skanera można wykorzystać plik <a href="main.py">main.py</a> lub <a href="main_oo.py">main_oo.py</a>
    (należy stworzyć odpowiednio skaner "strukturalny" scanner.py lub obiektowy scanner_oo.py).
<LI>Przykładowe wejście	<a href="example_full.txt">example_full.txt</a>
</UL>


</body>
</html>
